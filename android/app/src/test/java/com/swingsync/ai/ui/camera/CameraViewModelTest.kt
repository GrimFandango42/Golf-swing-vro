package com.swingsync.ai.ui.camera

import androidx.arch.core.executor.testing.InstantTaskExecutorRule
import com.swingsync.ai.achievements.AchievementSystem\nimport com.swingsync.ai.celebration.CelebrationEngine\nimport com.swingsync.ai.detection.BestSwingDetector\nimport com.swingsync.ai.domain.model.SwingSession\nimport com.swingsync.ai.domain.model.UserSettings\nimport com.swingsync.ai.domain.usecase.analysis.AnalyzeSwingUseCase\nimport com.swingsync.ai.domain.usecase.swing.*\nimport com.swingsync.ai.domain.usecase.user.GetUserSettingsUseCase\nimport com.swingsync.ai.domain.util.Result\nimport kotlinx.coroutines.Dispatchers\nimport kotlinx.coroutines.test.UnconfinedTestDispatcher\nimport kotlinx.coroutines.test.runTest\nimport kotlinx.coroutines.test.setMain\nimport org.junit.Assert.*\nimport org.junit.Before\nimport org.junit.Rule\nimport org.junit.Test\nimport org.mockito.Mock\nimport org.mockito.MockitoAnnotations\nimport org.mockito.kotlin.any\nimport org.mockito.kotlin.verify\nimport org.mockito.kotlin.whenever\n\n/**\n * Unit tests for CameraViewModel\n */\nclass CameraViewModelTest {\n    \n    @get:Rule\n    val instantTaskExecutorRule = InstantTaskExecutorRule()\n    \n    @Mock\n    private lateinit var createSwingSessionUseCase: CreateSwingSessionUseCase\n    \n    @Mock\n    private lateinit var updateSwingSessionUseCase: UpdateSwingSessionUseCase\n    \n    @Mock\n    private lateinit var savePoseDetectionUseCase: SavePoseDetectionUseCase\n    \n    @Mock\n    private lateinit var analyzeSwingUseCase: AnalyzeSwingUseCase\n    \n    @Mock\n    private lateinit var getUserSettingsUseCase: GetUserSettingsUseCase\n    \n    @Mock\n    private lateinit var bestSwingDetector: BestSwingDetector\n    \n    @Mock\n    private lateinit var celebrationEngine: CelebrationEngine\n    \n    @Mock\n    private lateinit var achievementSystem: AchievementSystem\n    \n    private lateinit var cameraViewModel: CameraViewModel\n    \n    private val testDispatcher = UnconfinedTestDispatcher()\n    \n    @Before\n    fun setUp() {\n        MockitoAnnotations.openMocks(this)\n        Dispatchers.setMain(testDispatcher)\n        \n        // Mock user settings\n        val userSettings = UserSettings(\n            userId = \"current_user\",\n            preferredClub = \"Driver\",\n            difficultyLevel = \"Beginner\",\n            unitsSystem = \"Imperial\",\n            voiceCoachingEnabled = true,\n            celebrationsEnabled = true,\n            autoSaveEnabled = true,\n            analysisNotificationsEnabled = true,\n            createdAt = 1000L,\n            updatedAt = 1000L\n        )\n        \n        runTest {\n            whenever(getUserSettingsUseCase(any())).thenReturn(Result.Success(userSettings))\n        }\n        \n        cameraViewModel = CameraViewModel(\n            createSwingSessionUseCase,\n            updateSwingSessionUseCase,\n            savePoseDetectionUseCase,\n            analyzeSwingUseCase,\n            getUserSettingsUseCase,\n            bestSwingDetector,\n            celebrationEngine,\n            achievementSystem\n        )\n    }\n    \n    @Test\n    fun `initial state should be correct`() {\n        // Then\n        assertEquals(CameraUiState.Idle, cameraViewModel.uiState.value)\n        assertEquals(false, cameraViewModel.isProcessing.value)\n        assertEquals(0f, cameraViewModel.currentFPS.value)\n        assertEquals(\"Driver\", cameraViewModel.selectedClub.value)\n        assertEquals(false, cameraViewModel.celebrationTriggered.value)\n        assertNull(cameraViewModel.currentSession.value)\n        assertNull(cameraViewModel.analysisResult.value)\n    }\n    \n    @Test\n    fun `startRecordingSession should create session and update state`() = runTest {\n        // Given\n        val swingSession = SwingSession(\n            sessionId = \"session123\",\n            userId = \"current_user\",\n            clubUsed = \"Driver\",\n            startTime = 1000L,\n            endTime = null,\n            totalFrames = 0,\n            fps = 30f,\n            videoPath = null,\n            isCompleted = false,\n            createdAt = 1000L,\n            updatedAt = 1000L\n        )\n        \n        whenever(createSwingSessionUseCase(any())).thenReturn(Result.Success(swingSession))\n        \n        // When\n        cameraViewModel.startRecordingSession(\"Driver\", 30f)\n        \n        // Then\n        assertEquals(CameraUiState.Recording, cameraViewModel.uiState.value)\n        assertEquals(true, cameraViewModel.isProcessing.value)\n        assertEquals(swingSession, cameraViewModel.currentSession.value)\n        assertNull(cameraViewModel.errorMessage.value)\n        verify(createSwingSessionUseCase).invoke(any())\n    }\n    \n    @Test\n    fun `startRecordingSession should handle errors`() = runTest {\n        // Given\n        val error = Exception(\"Failed to create session\")\n        whenever(createSwingSessionUseCase(any())).thenReturn(Result.Error(error))\n        \n        // When\n        cameraViewModel.startRecordingSession(\"Driver\", 30f)\n        \n        // Then\n        assertEquals(CameraUiState.Error, cameraViewModel.uiState.value)\n        assertEquals(false, cameraViewModel.isProcessing.value)\n        assertNotNull(cameraViewModel.errorMessage.value)\n        assertNull(cameraViewModel.currentSession.value)\n    }\n    \n    @Test\n    fun `stopRecordingSession should update session and state`() = runTest {\n        // Given\n        val initialSession = SwingSession(\n            sessionId = \"session123\",\n            userId = \"current_user\",\n            clubUsed = \"Driver\",\n            startTime = 1000L,\n            endTime = null,\n            totalFrames = 0,\n            fps = 30f,\n            videoPath = null,\n            isCompleted = false,\n            createdAt = 1000L,\n            updatedAt = 1000L\n        )\n        \n        val completedSession = initialSession.copy(\n            endTime = 2000L,\n            totalFrames = 100,\n            isCompleted = true,\n            updatedAt = 2000L\n        )\n        \n        whenever(createSwingSessionUseCase(any())).thenReturn(Result.Success(initialSession))\n        whenever(updateSwingSessionUseCase(any())).thenReturn(Result.Success(completedSession))\n        \n        // Start session first\n        cameraViewModel.startRecordingSession(\"Driver\", 30f)\n        \n        // When\n        cameraViewModel.stopRecordingSession()\n        \n        // Then\n        assertEquals(CameraUiState.Completed, cameraViewModel.uiState.value)\n        assertEquals(false, cameraViewModel.isProcessing.value)\n        assertEquals(completedSession, cameraViewModel.currentSession.value)\n        verify(updateSwingSessionUseCase).invoke(any())\n    }\n    \n    @Test\n    fun `isRecording should return correct state`() = runTest {\n        // Given\n        val recordingSession = SwingSession(\n            sessionId = \"session123\",\n            userId = \"current_user\",\n            clubUsed = \"Driver\",\n            startTime = 1000L,\n            endTime = null,\n            totalFrames = 0,\n            fps = 30f,\n            videoPath = null,\n            isCompleted = false,\n            createdAt = 1000L,\n            updatedAt = 1000L\n        )\n        \n        val completedSession = recordingSession.copy(\n            endTime = 2000L,\n            isCompleted = true,\n            updatedAt = 2000L\n        )\n        \n        whenever(createSwingSessionUseCase(any())).thenReturn(Result.Success(recordingSession))\n        whenever(updateSwingSessionUseCase(any())).thenReturn(Result.Success(completedSession))\n        \n        // Initially not recording\n        assertFalse(cameraViewModel.isRecording())\n        \n        // Start recording\n        cameraViewModel.startRecordingSession(\"Driver\", 30f)\n        assertTrue(cameraViewModel.isRecording())\n        \n        // Stop recording\n        cameraViewModel.stopRecordingSession()\n        assertFalse(cameraViewModel.isRecording())\n    }\n    \n    @Test\n    fun `clearError should clear error message`() {\n        // Given\n        cameraViewModel.clearError()\n        \n        // Then\n        assertNull(cameraViewModel.errorMessage.value)\n    }\n    \n    @Test\n    fun `clearCelebrationTrigger should clear celebration state`() {\n        // When\n        cameraViewModel.clearCelebrationTrigger()\n        \n        // Then\n        assertEquals(false, cameraViewModel.celebrationTriggered.value)\n    }\n}"